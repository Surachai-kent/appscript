MacPythonOSA Notes

----------------------------------------------------------------------
Python interpreter usage

Component Manager loads component only once. At minimum, each component instance MUST have its own sub-interpreter (stored in its componentState struct). Py_Initialize() should be called if not previously initialised. Py_Finalize() is unsafe to call unless we keep count of the number of component instances already open and only call it when that count reaches 0. See:

<file://localhost/Users/has/PythonDev/~Docs/Python-Docs-2.3.2/api/initialization.html>, PyThreadState*ÊPy_NewInterpreter()

I suspect one sub-interpreter per script might be best to avoid problems caused by module/stdout/stderr sharing between disparate scripts, but might this cause problems when chaining contexts? Each sub-interpreter would be initialised when script is loaded/compiled, and destroyed when script is destroyed. (How expensive would this be?)

However, if script A executes in context of script B, do we want script A to share B's interpreter? If we do, we get lower overheads and data sharing between loaded modules. If we don't, there's no sharing at all and all inter-script communication will be via OSA. Are there any implications to spawning lots of sub-interpreters?

Ideally, we want more than one script able to run at a time in [e.g.] SE (SE creates a single component instance, rather than one per document, which is maybe not the most sensible choice), so even if we didn't have one sub-interpreter per script we might want to thread script execution to avoid blocking. OTOH, this might cause _really_ interesting interactions in shared modules, and doesn't seem at all safe. At least with a single thread we might be able to reload all modules before running (except this'd ruin a stored script's persistent state, which isn't very good).


----------------------------------------------------------------------
Initialisation and execution of stored scripts

AppleScript/OSA treat script initialisation and execution as separate operations. This is much like loading a Python module, which initialises it, vs calling its functions, which actually does something useful. AS/OSA scripts can retain their current state between runs until they're recompiled, just as Python modules retain their state until they're reloaded. IOW, compiled AS scripts and Python modules are very similar in their nature, although AS uses some extra compiler trickery to allow 'run' code to appear at the top level of the script, rather than requiring you to declare an explicit 'on run...end run' block each time.

It is very UNlike writing a simple batch-processing script in Python that both initialises and executes in a single step, so if you put such a script into SE, it will run when compiled, and not when run! Therefore, MacPythonOSA scripts will NOT be interchangeable with Python shell scripts, though they will be interchangeable with Python modules (as long as they don't use relative imports; see below).

To write a standard batch-processing script in MacPythonOSA, construct its code as follows:

<initialisation code goes here>
def run(*args):
	<execution code goes here>


----------------------------------------------------------------------
Support for persistent data in stored scripts

MacPythonOSA supports persistence differently to AppleScript. Rather than try to pickle the entire state of the script _plus_ all the modules it's loaded (an almost impossible task), we provide each script context with a dedicated 'osastore' slot where users can store any data they wish to preserve between executions. 

Example declaration:

osastore(
	x = 0,
	y = 1,
	) # values of x and y persist between runs

z = 2 # value of z persists for a single run


Example usage:

val = osastore.x


The osastore object's state is only set once, when the script is first run. When the script is saved the current state is serialised and stored in the script file. When the script file is loaded, the serialised data is restored to osastore before the script is initialised; thus persistent state persists while everything else is recreated around it (modules reloaded, functions redeclared, etc).

Recompiling the script will, of course, reinitialise osastore's state.

Users should take care what types of values they store: all data must be serialisable or the client's OSAStore() call will fail. Note that scripts are currently serialised using the marshal module (this isn't ideal, but pickle can't handle functions, methods, code objects, etc. so isn't adequate for our purposes). This may, of course, change in the future.

----------------------------------------------------------------------
Module import limitation

MacPythonOSA scripts can't [normally] import modules relative to themselves. OSA has no concept of filesystem, and doesn't provide any way to find out where a given script has come from. 

The best we can offer is to supply an optional module, relativeimport, that tries to discover the scripts location by sending a 'path to me' event to the client application. Where the host is a script applet, this will effectively return the path to the script, or at least to the application bundle it's in (depending on which format the applet is), and some OSA script editors and other apps also respect this kludge and return a path to the saved script file (where onr exists), though others will return a path to themselves so it's not 100% reliable. 

(Note: 'path to me' is really a bug that effectively has the same meaning as 'path to current application'. It's commonly used by ASers and has to-date been left intentionally unfixed due to its usefulness and the number of scripts it'd break.)


----------------------------------------------------------------------
AEDesc memory management

To avoid MacPythonOSA component and its client arguing over ownership of any AEDescs handed to component by client, the component always makes local duplicates for use by the component controller module. This avoids component or client prematurely dealloc-ing an AEDesc that's still being used by the other, though at the expense of additional data copying. i.e. Slow but safe. Hopefully we can do away with this duplication once the controller codebase settles down and we can determine how safe it'll be to share data.


----------------------------------------------------------------------

Notes

- Avoid importing EasyDialogs as it causes the component to barf (ED imports Carbon.AE, which isn't compatible with use of CarbonX.AE); restarting host app clears fault.
