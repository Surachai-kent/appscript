<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

<title>macfile</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<style type="text/css" media="all"><!--@import url(../appscript-manual/full.css);--></style>

</head>
<body>

<h1>macfile</h1>

<!-- top navigation -->
<div class="navbar">
    <a href="index.html">Up</a>
    
</div>

<!-- content -->
<div id="content">
<h2>What is macfile?</h2>

<p>The macfile module provides user-friendly wrappers for OS X Alias and File objects, commonly used by scriptable applications to identify filesystem objects and locations.</p>

<p class="hilitebox">Note that most scriptable applications do not use or understand POSIX paths, and while the Apple Event Manager does provide some built-in coercions for converting between path strings and alias/file objects, these work with HFS paths only. Therefore, when specifying files and folders to scriptable applications, use <code>MacFile::Alias</code> and <code>MacFile::File</code> objects - not path strings - unless otherwise indicated.</p>


<h2><code>MacFile::Alias</code></h2>

<p>The <code>Alias</code> class represents a persistent reference to a filesystem object. Aliases keep track of filesystem objects even if they're renamed or moved to another location on the same disk.</p>


<h3>Methods</h3>

<pre><code>Alias -- a persistent reference to a filesystem object
    Constructors:

        Alias.at(path) -- make Alias object from POSIX path
    
        Alias.newDesc(desc) -- make Alias object from an AE::AEDesc
                               of TypeAlias

    Methods:

        desc -- returns AE::AEDesc of typeAlias
    
        to_s -- returns POSIX path string to the object's current location
    
        inspect -- returns string representation of Alias object
    
        to_Alias -- returns self
    
        to_FileURL -- returns a MacFile::FileURL object</code></pre>


<h3>Examples</h3>

<pre><code>require "appscript"
require "macfile"

f = MacFile::Alias.at('/Users/foo/some file')

puts f.to_s
# /Users/foo/some file

puts f.inspect
# MacFile::Alias.at("/Users/foo/some file")

AS.app('TextEdit').open(f)
# opens document in TextEdit</code></pre>



<h2><code>MacFile::FileURL</code></h2>

<p>The <code>FileURL</code> class represents a fixed filesystem location. This may be deterministic (i.e. existing locations only) or non-deterministic depending on how the object is created.</p>

<h3>Methods</h3>

<pre><code>FileURL -- identifies a fixed filesystem location
    Constructors:

        FileURL.at(path) -- make FileURL object from POSIX path
    
        FileURL.newDesc(desc) -- make FileURL object from an AE::AEDesc
                                 of TypeFSS, TypeFSRef or TypeFileURL

    Methods:

        desc -- returns self
    
        to_s -- returns POSIX path string
    
        inspect -- returns string representation of FileURL object
    
        to_Alias -- returns a MacFile::Alias object
    
        to_FileURL -- returns self</code></pre>

<h3>Examples</h3>

<pre><code>require "appscript"
require "macfile"

f = MacFile::FileURL.at('/Users/foo/new file')

puts f.to_s
# /Users/foo/new file

puts f.inspect
# MacFile::FileURL.at("/Users/foo/new file")

AS.app('TextEdit').documents[1].save(:in => f)
# saves front TextEdit document at the given location</code></pre>


<h3>Notes</h3>

<ul>
<li>A <code>FileURL</code> object created via the <code>at</code> constructor will always pack into an AEDesc of <code>TypeFileURL</code>.</li>

<li>Whereas the <code>Alias</code> class wraps <code>TypeAlias</code> values only, the <code>FileURL</code> class provides a uniform wrapper for several file-related types that may be returned by applications: <code>TypeFSS</code>, <code>TypeFSRef</code> and <code>TypeFileURL</code>.</li>

<li><p>When passing <code>FileURL</code> values to applications, you should not normally need to worry about which value type a <code>FileURL</code> object contains as well-designed applications will ask the Apple Event Manager to coerce the given value to the desired type as necessary.</p>
<p>When dealing with less well-behaved applications, however, you may need to pass an AEDesc of a specific type. In this case you should use the <code>desc</code> method to obtain an <code>AE::AEDesc</code> object, then call its <code>coerce</code> method to obtain an AEDesc of the desired type. For example, if an older Carbon application refuses to accept a FileURL identifying a non-existing file location, you may need to provide a FSSpec insteaf:</p>

<pre><code>require "macfile"
require "kAE"

fileURL = MacFile::FileURL.at('/Users/foo/new file')

fsspec = fileURL.desc.coerce(KAE::TypeFSS)

AS.app('older app').documents[1].save(:in => fsspec)</code></pre>
</li>


<li>AEDescs of <code>TypeFSRef</code> can represent existing filesystem locations only. AEDescs of <code>TypeFileURL</code> can represent both existing and non-existing locations.</li>

<li>FSSpecs (<code>TypeFSS</code>) are deprecated on Mac OS X due to lack of proper Unicode and long filename support, and are retained for backwards compatibility with older applications only.</li>
</ul>

<h2><code>MacFile::FileNotFoundError</code></h2>

<p><code>FileNotFoundError</code> is a subclass of <code>RuntimeError</code>. It is raised by <code>Alias</code> and <code>FileURL</code> objects to indicate that an operation that only works for existing filesystem objects/locations has failed. For example:</p>

<pre><code>require "macfile"

MacFile::Alias.at('/some/non/existent/location')
# raises FileNotFoundError</code></pre>


</div>

<!-- bottom navigation -->
<div class="navbar">
    <a href="index.html">Up</a>
    
</div>

<!--footer-->
<p class="footer">&copy; 2006 HAS</p>
</body>
</html>