<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

<title>appscript | 14. Dealing With Problem Applications</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<style type="text/css" media="all"><!--@import url(full.css);--></style>

</head>
<body>

<h1>14. Dealing With Problem Applications</h1>

<!-- top navigation -->
<div class="navbar">
	<a href="13_performanceissues.html">Previous</a> | <a href="index.html">Up</a> | <a href="15_notes.html">Next</a>
	
</div>

<!-- content -->
<div id="content">

<p>Appscript provides a number of mechanisms for dealing with problematic applications. The following topics are covered in this chapter:</p>

<ul>
<li><a href="#non_stay_open_applications">Scripting non-stay-open applications</a></li>
<li><a href="#unit_type_definitions">Adding third-party unit type definitions</a></li>
<li><a href="#avoid_faulty_terminology">Mixing aem and appscript code</a></li>
<li><a href="#fix_faulty_terminology">Fixing faulty terminology data</a></li>
</ul>


<!-- TO DO:
- patching AS_app_data codecs
- FSRef/FileURL/FSSpec, string/unicode/international text compatibility issues with older apps 
-->




<h2><a name="non_stay_open_applications">Scripting non-stay-open applications</h2>

<p>When scripting AppleScript applets and other applications that take only a single <code>run</code> or <code>open</code> event, scripts must take some additional steps to avoid problems:<p>

<ol>
<li>When creating an application object, the <code>:terms</code> argument must be <code>false</code>. This will prevent appscript from repeatedly starting the application in an (unsuccessful) attempt to retrieve its terminology.</li>

<li>When sending an <code>open</code> event, the application must first be started using the <code>launch</code> command to avoid it receiving the usual <code>run</code> event upon start-up.</li>

<li>Since non-stay-open applications don't reply to commands, the <code>run</code>/<code>open</code> command's <code>:wait_reply</code> argument must be <code>false</code> to prevent appscript waiting for a non-existent response.</li>
</ol>

<p>Examples:</p>

<pre><code>require "appscript"

# Run
Appscript.app('Foo', false).run(:wait_reply => false)

# Open
bar = Appscript.app('Bar', false)
bar.launch
bar.open([MacFile::Alias.path('/path/to/item 1'), ...], :wait_reply => false)</code></pre>



<h2><a name="unit_type_definitions">Adding third-party unit type definitions</h2>

<p>Appscript defines a number of default unit types for specifying measurements (see <a href="../mactypes-manual/index.html">mactypes manual</a>), but some applications (e.g. Adobe Photoshop) may define additional unit types in addition to these. Appscript provides a mechanism for adding custom unit type definitions to individual application objects.</p>

<h3>Defining custom unit types</h3>

<p>Each definition is specified as a two- or four-item list:</p>

<pre><code>[typename, typecode]

or:

[typename, typecode, packproc, unpackproc]</code></pre>

<dl>
<dt>typename</dt>
<dd>A symbol representing the unit type name, e.g. <code>:pixels</code>. This symbol should be a valid Ruby identifier.</dd>

<dt>typecode</dt>
<dd>A four-character string representing the unit type code, e.g. <code>"\x81PX\x8c"</code>. This will be used as the AEDesc's type when packing and unpacking unit type values.</dd>

<dt>packproc</dt>
<dd>An optional procedure that packs a <code>MacTypes::Units</code> value into an <code>AE::AEDesc</code>. This procedure should take two arguments: a <code>MacTypes::Units</code> instance and the <code>typecode</code>, and return an <code>AE::AEDesc</code> instance.</dd>

<dt>unpackproc</dt>
<dd>An optional procedure for unpacking an <code>AE::AEDesc</code> into a <code>MacTypes::Units</code> value. This procedure should take two arguments: an <code>AE::AEDesc</code> instance and the <code>typename</code>, and return a <code>MacTypes::Units</code> instance.</dd>
</dl>

<p>If the <code>packproc</code> and <code>unpackproc</code> items are omitted, the built-in pack/unpack procedures are used to pack and unpack the unit type value as a native-endian double:</p>

<pre><code>DefaultPacker = proc { |units, code| AE::AEDesc.new(code, [units.value].pack('d')) }
DefaultUnpacker = proc { |desc, name| MacTypes::Units.new(desc.data.unpack('d')[0], name) }</code></pre>

<h3>Adding unit type definitions</h3>

<p>The aem <code>Codecs</code> class defines a single instance method, <code>add_unit_types</code> that takes a list of one or more unit type definitions and adds them to those already defined. Each  appscript application object contains an <code>AppData</code> instance (<code>Appscript::AppData</code> is a subclass of <code>AEM::Codecs</code>) which can be obtained by calling the application object's <code>AS_app_data</code> method. You can then call <code>AppData#add_unit_types</code> to add the custom unit type definitions for that application object.</p>

<pre><code>require "appscript"

# Define application-specific unit types:
AdobeUnitTypes = [
	[:millimeters, "\x81MM\x8c"],
	[:points, "\x81PS\x8c"],
	[:picas, "\x81SP\x8c"],
	[:traditional_points, "\x81PT\x8c"],
	[:traditional_picas, "\x81PC\x8c"],
	[:ciceros, "\x81CR\x8c"],
	[:percent, "\x81PN\x8c"],
	[:pixels, "\x81PX\x8c"],
]

# Create an application object:
Photoshop = Appscript.app("Adobe Photoshop CS2")

# Add the custom unit type definitions to this application object:
Photoshop.AS_app_data.add_unit_types(AdobeUnitTypes)

# Rest of script goes here...</code></pre>




<h2><a name="avoid_faulty_terminology"></a>Mixing aem and appscript code</h2>

<p>There are two ways to deal with missing or incorrect terminology: avoid it by using aem instead of appscript, or export it with the <code>dump</code> tool and fix it by hand.</p>

<p>If faulty terminology prevents you from correctly constructing an appscript reference or command, one solution is to use the lower-level aem module, which uses raw codes instead of human-readable names.</p>

<p>An <code>Appscript::Reference</code> object is just a thin wrapper around an aem reference and an <code>AppData</code> object containing application terminology, pack/unpack methods, and an <code>AEM::Application</code> instance. While it's generally not encouraged, it is possible to retrieve these values via the <code>AS_aem_reference</code> and <code>AS_app_data</code> methods and manipulate them directly.</p>

<p class="hilitebox">See the <a href="../aem-manual/index.html">aem documentation</a> for a full description of the aem API and how to use it. You can use the <a href="http://sourceforge.net/project/showfiles.php?group_id=175009">ASDictionary</a> application to generate a plain text description of an application's raw Apple event codes for use with aem.</p>

<h3>Working around bad references</h3>

<p>You can work around broken property or element terminology by extracting this aem reference and working with it instead. To obtain an aem reference from an appscript reference, call the appscript reference's <code>AS_aem_reference</code> method. For example:</p>

<pre><code>require 'appscript'

TextEdit = Appscript.app('TextEdit')

appscript_ref = TextEdit.documents[1].text

aem_ref = appscript_ref.AS_aem_reference

p aem_ref
# AEM.app.elements('docu').by_index(1).elements('ctxt')</code></pre>

<p>Once you've obtained an aem reference, you can call its methods to construct new aem references without relying on any application terminology.</p>

<p>Note that you can use an aem reference directly as a selector in a by-range or by-filter appsccript reference, or as a parameter in an appscript command; for example:</p>

<pre><code>TextEdit.get(aem_ref)</code></pre>

<p>You can also use appscript's <code>Application#AS_new_reference</code> method to convert an aem reference into an appscript reference:</p>

<pre><code>aem_ref = AEM.app.elements('docu').by_index(1).elements('ctxt')

appscript_ref = TextEdit.AS_new_reference(aem_ref)

p appscript_ref
# app("/Applications/TextEdit.app").documents[1].text</code></pre>


<h3>Working around bad commands</h3>

<p>Working around broken command terminology is a little more complex. The first step is to obtain an <code>AppData</code> object for packing and unpacking the event parameters and result, e.g.:</p>

<pre><code>te_app_data = TextEdit.AS_app_data</code></pre>

<p>Next, call <code>AppData#target</code> to obtain the <code>AEM::Application</code> instance for the target application:</p>

<pre><code>te_app = te_app_data.target</code></pre>

<p>To build and send an Apple event, call the <code>AEM::Application</code> object's <code>event</code> method, passing the <code>AppData</code> object for that application as its <code>codecs</code> argument, then call the resulting <code>Event</code> object's <code>send</code> to send it:</p>

<pre><code>reply = te_app.event(
        'coregetd',
        {'----' =&gt; TextEdit.documents},
        {},
        KAE.KAutoGenerateReturnID,
        te_app_data).send

p reply
# [app('/Applications/TextEdit.app').documents[1], ...]</code></pre>



<h3>Working around bad class or enumerator names</h3>

<p>Appscript normally represents class and enumerator names as Ruby symbols, e.g. <code>:document</code>. If the terminology for these is missing or broken, just use <code>AEM::AEType</code> and <code>AEM::AEEnum</code> instead.</p>




<h2><a name="fix_faulty_terminology"></a>Fixing faulty terminology data</h2>

<p>Another way to deal with buggy or incomplete application terminology is to export it as a Ruby module and correct it by hand. Appscript can then use the terminology data from this module instead of the broken terminology from the application itself.</p>

<p>Exporting an application's terminology is done using the <code>dump.rb</code> script located in the <code>misc</code> folder. This script is designed to be run from the command line, and takes three arguments: the name or path of the application whose terminology you wish to export, followed by the new module's Ruby name and file path. For example:</p>

<pre><code>ruby dump.rb iCal.app ICalTerminology ~/ical_terms.rb</code></pre>

<p>The dump tool will generate a new Ruby module similar to the following:</p>

<pre><code>module ICalTerminology
	Version = 1.1
	Path = "/Applications/iCal.app"

	Classes = [
		["application", "capp"],
		["attachment", "atts"],
		["attendee", "wrea"],
		...
	]

	Enumerators = [
		["accepted", "E6ap"],
		["ask", "ask "],
		...
	]

	Properties = [
		["allday_event", "wrad"],
		["bounds", "pbnd"],
		...
	]

	Elements = [
		["applications", "capp"],
		["attachment", "atts"],
		...
	]

	Commands = [
		["GetURL", "GURLGURL", [
		]],
		["close", "coreclos", [
			["saving", "savo"],
			["saving_in", "kfil"],
		]],
		...
	]
end</code></pre>

<p>Every terminology module contains the following constants:</p>

<dl>
<dt>Version</dt>
<dd>Indicates the terminology module's format. This is currently 1.1.</dd>

<dt>Path</dt>
<dd>The application from which this terminology was obtained.</dd>

<dt>Classes</dt>
<dd>A list of class names and their corresponding four-character codes as name-code pairs, e.g. <code>["document", "docu"]</code>.</dd>

<dt>Enumerators</dt>
<dd>A list of enumerator names and their corresponding four-character codes as name-code pairs, e.g. <code>["yes", "yes "]</code>.</dd>

<dt>Properties</dt>
<dd>A list of property names and their corresponding four-character codes as name-code pairs, e.g. <code>["name", "pnam"]</code>.</dd>

<dt>Elements</dt>
<dd>A list of element names and their corresponding four-character codes as name-code pairs, e.g. <code>["documents", "docu"]</code>. Note that this list should be identical to the <code>Classes</code> list, except that each element name should be the plural form of the corresponding class name.</dd>

<dt>Commands</dt>
<dd>A list of command names and their corresponding eight-character codes, followed by a list of keyword argument names and their corresponding four-character codes as name-code pairs, e.g. <code>["make", "corecrel", [["new", "kocl"],...]]</code>.</dd>
</dl>

<p>You can edit any of the five terminology lists as needed, e.g. to add missing class and element definitions, to correct faulty four-character codes, etc. (Make sure any changes are correctly formatted as appscript doesn't perform any special error checking when reading data from this module.) Once the changes are complete, place the module file somewhere on Ruby's module search path (e.g. in <code>/usr/lib/ruby/site_ruby/1.8</code>) so it can be imported into scripts when needed.</p>

<p>To use a terminology module, first import it as normal. Then, when creating a new application object for the problem application, pass this module to the constructor call as its second argument (or first argument if it's the <code>current</code> constructor). For example:</p>

<pre><code>require "appscript"
require "ical_terms"

ical = Appscript.app('iCal', ICalTerminology)
...</code></pre>

<p>Finally, remember to file a bug report with the application's developer so that they can fix the problem in a future release!</p>



</div>

<!-- bottom navigation -->
<div class="navbar">
	<a href="13_performanceissues.html">Previous</a> | <a href="index.html">Up</a> | <a href="15_notes.html">Next</a>
	
</div>

<!--footer-->
<p class="footer">&copy; 2006 HAS</p>
</body>
</html>