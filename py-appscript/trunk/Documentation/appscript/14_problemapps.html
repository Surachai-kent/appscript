<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

<title>appscript | 13. Dealing With Problem Applications</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<style type="text/css" media="all"><!--@import url(full.css);--></style>

</head>
<body>



<!-- TO DO: dump format; telltarget; patching AS_appdata codecs; 3rd-party unit types mechanism -->


<h1>13. Dealing With Problem Applications</h1>

<!-- top navigation -->
<div class="navbar">
	<a href="13_performanceissues.html">Previous</a> | <a href="index.html">Up</a> | <a href="15_notes.html">Next</a>
	
</div>

<!-- content -->
<div id="content">

<p>Appscript provides a number of mechanisms for dealing with problematic applications, particularly those with missing or incorrect terminology.</p>

<h2>Working around defective terminology</h2>

<p>There are two ways to work around missing or incorrect terminology: use <code>aem</code> or use appscript's <code>dump</code> module.</p>

<h3>Use <code>aem</code></h3>

<p>If faulty terminology prevents you from correctly constructing an appscript reference or command, one solution is to use the lower-level <code>aem</code> package, which uses raw codes instead of human-readable names.</p>

<p>The <code>osaterminology</code> package provides tools for listing the codes in an application's terminology. The <code>aem</code> documentation provides details of the <code>aem</code> API and how to use it.</p>

<p>Note that you can obtain an <code>aem</code> reference from an existing <code>appscript</code> reference by getting the value of its <code>AS_aemreference</code> attribute. You can also pass an <code>aem</code> reference as a parameter to an <code>appscript</code> command. (You cannot use an <code>appscript</code> reference in an <code>aem</code> event, however; you have to extract its <code>aem</code> reference and use that.)</p>

<p>For example:</p>

<pre><code>aemref = app('TextEdit').documents[1].text.AS_aemreference
# app.elements('docu').byindex(1).elements('ctxt')

app('TextEdit').get(aemref)</code></pre>



<h3>Use <code>dump</code></h3>

<p>The <code>appscript.tools.dump</code> module allows you to export the name-code translation tables for an application as a Python module. Any errors and omissions can then be corrected by hand by hand.</p>

<p>The <code>dump</code> module exports a single function, also named <code>dump</code>:</p>

<pre><code>dump(apppath, modulepath) -- Dump terminology data to Python module.
    apppath : str -- name/path of application
    modulepath : str -- path to generated module</code></pre>

<p>This module can then be placed in <code>site-packages</code> or other suitable location. I can then be imported and used as the <code>app</code> constructor's <code>terms</code> argument. See the <a href="07_applicationobjects.html">Application Objects</a> chapter for more information.</p>




<h2>Scripting non-stay-open applications</h2>

<p>When scripting AppleScript applets and other applications that take only a single <code>run</code> or <code>open</code> event, scripts must take some additional steps to avoid problems:<p>

<ol>
<li>When creating an application object, the <code>terms</code> argument must be <code>False</code>. This will prevent appscript from repeatedly starting the application in an (unsuccessful) attempt to retrieve its terminology.</li>

<li>When sending an <code>open</code> event, the application must first be started using the <code>launch</code> command to avoid it receiving the usual <code>run</code> event upon start-up.</li>

<li>Since non-stay-open applications don't reply to commands, the <code>run</code>/<code>open</code> command's <code>waitreply</code> argument must be <code>False</code> to prevent appscript waiting for a non-existent response.</li>
</ol>

<p>Examples:</p>

<pre><code>from appscript import *
from macfile import *

# Run
app('Foo', terms=False).run(waitreply=False)

# Open
bar = app('Bar', terms=False)
bar.launch()
bar.open([Alias('/path/to/item 1'), ...], waitreply=False)</code></pre>



</div>

<!-- bottom navigation -->
<div class="navbar">
	<a href="13_performanceissues.html">Previous</a> | <a href="index.html">Up</a> | <a href="15_notes.html">Next</a>
	
</div>

<!--footer-->
<p class="footer">&copy; 2004 HAS</p>
</body>
</html>