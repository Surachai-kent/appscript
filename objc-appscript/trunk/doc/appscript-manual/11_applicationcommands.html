<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

<title>appscript | 11. Application Commands</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<style type="text/css" media="all"><!--@import url(full.css);--></style>

</head>
<body>

<h1>11. Application Commands</h1>

<!-- top navigation -->
<div class="navbar">
	<a href="10_referenceexamples.html">Previous</a> | <a href="index.html">Up</a> | <a href="12_commandexamples.html">Next</a>
	
</div>

<!-- content -->
<div id="content">


<p class="hilitebox">Note: the appscript command API is currently unfinished and may change in future. Transaction and return IDs are not yet supported, the send mode API may be added to or replaced, and the design of the error reporting system has still to be finalised.</p>

<h2>Using commands</h2>

<p>Sending application commands in objc-appscript involves the following steps:</p>

<ol>
<li>Create a new command instance, optionally supplying a direct parameter.</li>
<li>Add any attributes and/or keyword parameters to the command.</li>
<li>Send the command to the application.</li>
<li>Check for application-generated errors and/or a return value, if any.</li>
</ol>

<p>This granular approach provides plenty of power and flexibility along with a reasonably terse, efficient syntax.</p>


<h3>Creating a command</h3>

<p>Each application command is defined as a pair of methods on the glue's Application and Reference classes. One takes a value representing the command's direct parameter as its single argument, the other doesn't. For example, TextEdit's <code>duplicate</code> command is represented as:</p>

<pre><code>- (TEMakeCommand *)duplicate;
- (TEMakeCommand *)duplicate:(id)directParameter;</code></pre>

<p>(Note that all commands take this form, regardless of whether the application dictionary lists them as taking a direct parameter or not; it's up to the client to use them as appropriate.)</p>

<h3>Adding keyword parameters</h3>

<p>Once a command object has been created, keyword parameters can be added one at a time. Each keyword parameter is represented by a method of the command object that takes a value of any class and returns <code>self</code>, allowing multiple parameter calls to be chained together for convenience. For example, TextEdit's <code>TEMakeCommand</code> class defines the following parameter methods:</p>

<pre><code>- (TEMakeCommand *)to:(id)value;
- (TEMakeCommand *)withProperties:(id)value</code></pre>

<p>Note: all required parameters must be supplied, along with zero or more optional parameters, before the command is sent, otherwise the target application will raise a 'missing parameter' error.</p>


<!-- TO DO: specifying considering/ignoring flags -->

<h3>Specifying send mode flags</h3>

<p>Every command object provides a <code>-sendMode:</code> method for specifying how the target application should handle the event:</p>

<pre><code>- (id)sendMode:(AESendMode)flags;</code></pre>

<p>The Apple Event Manager defines the following <code>AESendMode</code> constants:</p>

<pre><code>enum {
    kAENoReply = 0x00000001,
    kAEQueueReply = 0x00000002,
    kAEWaitReply = 0x00000003,

    kAENeverInteract = 0x00000010,
    kAECanInteract = 0x00000020,
    kAEAlwaysInteract = 0x00000030,

    kAECanSwitchLayer = 0x00000040,

    kAEDontRecord = 0x00001000,
    kAEDontExecute = 0x00002000,

    kAEProcessNonReplyEvents = 0x00008000
};</code></pre>

<p>By default, appscript uses <code>kAEWaitReply</code> and <code>kAECanSwitchLayer</code>.</p>

<p>See the Apple Event Manager documentation for more information.</p>



<h3>Specifying the event timeout</h3>

<p>Every command object provides a <code>-timeout:</code> method for specifying the number of seconds the sender is willing to wait for the target application to reply when the <code>kAEWaitReply</code> send mode is used:</p>

<pre><code>- (id)timeout:(long)timeout_;</code></pre>

<p>The Apple Event Manager defines two constants that may also be used here:</p>

<pre><code>enum {
   kAEDefaultTimeout = -1,
   kNoTimeOut = -2
};</code></pre>

<p>See the Apple Event Manager documentation for more information.</p>



<h3>Specifying the reply value's type</h3>

<p>Where supported by the target application's event handler, the sender can use a command object's <code>-requestType:</code> method to specify the desired type for the reply value:</p>

<pre><code>- (id)requestType:(ASConstant *)type;</code></pre>

<p>The target application will attempt to coerce the reply value to this type before returning it. The argument is usually a standard AE type, e.g. <code>[ASConstant alias]</code>, though may occasionally be an application-defined type.</p>


<h3>Specifying the required result type</h3>

<p>The <code>-resultType:</code> method specifies the AE type that the returned result descriptor must be coerced to before unpacking it:</p>

<pre><code>- (id)resultType:(DescType)type;</code></pre>

<p>Whereas the <code>-requestType:</code> method adds a <code>kAERequestedType</code> parameter to the outgoing event, this coercion is performed locally by the <code>-send:</code> method using a built-in/user-installed AE coercion handler if one is available. Note that if the coercion fails, <code>-send:</code> will return <code>nil</code> and set the command object's error number to <code>errAECoercionFail</code> (-1700).</p>


<h3>Sending a command</h3>

<p>To send a command, just call its <code>-send</code> method. This will send the command to the application and return one of the following:</p>

<ul>
<li>If the command is successful and the application supplies a return value, that value is returned.</li>

<li>If the command is successful and the application doesn't supply a return value, an <code>NSNull</code> instance is returned.</p>

<li>If the command is unsuccessful, either due to an Apple Event Manager error or an application error, <code>nil</code> is returned to indicate failure.</li>
</ul>


<h3>Checking for command errors</h3>

<p>Code that needs to know if an application command was unsuccessful should check the <code>-send</code> method's return value to see if it returned nil. If it did, error information can be obtained by calling the command object's <code>-errorNumber</code> and <code>-errorString</code> methods:</p>

<pre><code>- (OSErr)errorNumber;
- (NSString *)errorString;</code></pre>

<h3>Example</h3>

<p>AppleScript:</p>

<pre><code>try
    tell application "TextEdit"
        return make new document with properties {text:"Hi!"}
    end tell
on error errString number errNumber
    return "error:\n number: " & errNumber & "\n message: " & errString 
end try</code></pre>

<p>ObjC:</p>

<pre><code>TEApplication *textedit;
TEMakeCommand *makeCmd;
id result;

textedit = [[TEApplication alloc] initWithName: @"TextEdit.app"];

makeCmd = [[[textedit make]
                      new_: [TEConstant document]]
            withProperties: [NSDictionary dictionaryWithObjectsAndKeys:
                                      @"Hi 2!", [TEConstant text], nil]];
result = [makeCmd send];
if (result) 
    NSLog(@"result:\n%@\n\n", result);
else
    NSLog(@"error:\n number: %i\n message: %@\n\n",
            [makeCmd errorNumber], [makeCmd errorString]);</code></pre>


<h2>Examples</h2>

<pre><code>// tell application &quot;TextEdit&quot; to activate
[[textedit activate] send]

// tell application &quot;TextEdit&quot; to open fileRefList
[[textedit open: fileRefList] send]

// tell application &quot;Finder&quot; to get version
[[[finder version] get] send]

// tell application &quot;Finder&quot; to set name of file &quot;foo.txt&quot; of home to &quot;bar.txt&quot;
[[[[[[[finder home] files] byName: @"foo.txt"] name] set] to: @"bar.txt"] send]

// tell application &quot;TextEdit&quot; to count (text of first document) each paragraph
[[[[[[textedit documents] first] text] count] each: [TEConstant paragraph]] send]

// tell application &quot;TextEdit&quot; to make new document at end of documents
[[[[[textedit documents] end] make] new_: [TEConstant document]] send]<!--
// tell application &quot;Finder&quot; to get items of home as alias list
[finder home] items] get(:result_type =&gt; :alias)--></code></pre>



<h2>Special cases</h2>

<p>The following special-case behaviours are implemented for convenience:</p>

<ol>
<li><p>Commands that take a reference to one or more application objects as their direct parameter may be written in the following form:</p>

<pre><code>[reference command]</code></pre>

<p>The conventional  form is also supported should you ever wish (or need) to use it:</p>

<pre><code>[application command: reference]</code></pre>

<p>The two forms are equivalent (appscript converts the first form to the second behind the scenes) although the first form is preferred for conciseness.</p></li>


<li><p>If a command is called on a reference object and a direct parameter is also given, i.e.:</p>

<pre><code>[reference command: directParameter]</code></pre>

<p>the reference upon which it is called will be packed as the Apple event's 'subject' attribute (<code>keySubjectAttr</code>).</p></li>


</ol>


</div>

<!-- bottom navigation -->
<div class="navbar">
	<a href="10_referenceexamples.html">Previous</a> | <a href="index.html">Up</a> | <a href="12_commandexamples.html">Next</a>
	
</div>

<!--footer-->
<p class="footer">&copy; 2007 HAS</p>
</body>
</html>