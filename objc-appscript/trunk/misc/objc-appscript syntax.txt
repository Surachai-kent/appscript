

======================================================================
DISCUSSION

Py-appscript and rb-appscript are completely dynamic, retrieving application terminology at runtime and constructing internal lookup tables which are then used by __getattr__/__call__/method_missing to construct references and commands. 

Objc-appscript could follow the same approach by using forwardInvocation: (as long as a safe, stable base class can be procured, otherwise the forwardInvocation: behaviour can be disrupted by third-parties adding categories to NSObject).

Alternatively, objc-appscript could use #include-able glue files generated at compile-time, one glue per application being scripted. Glue files would avoid the base class safety issue, and allow slightly better support for compile-time type-checking (which ObjC developers will likely prefer).


======================================================================
GENERATING GLUES

A command-line utility, osaglue, should be used to generate glue files for objc-appscript. (Aside: osaglue could also be extended to support py-appscript and rb-appscript's dump feature.)

Syntax:

    osaglue --namespace prefix [--filename name] [application-name]

- The --namespace argument is prepended to all classes, globals, etc. in the glue. Developers are of course responsible for specifying unique prefixes that won't cause namespace conflicts in their project.

- The --filename argument can be used to specify the glue files' base name (e.g. 'FinderBindings' -> FinderBindings.h, FinderBindings.m). If the --filename argument is omitted, the namespace prefix is  prepended to 'Glue.h' and 'Glue.m' to construct the glue file names.

- The application-name argument may be a name, path or eppc:/ URL; if omitted, a glue containing only the default terminology is created.


For example, to generate TEGlue.h, TEGlue.m files for TextEdit:

    osaglue --namespace TE TextEdit


======================================================================
GLUE INTERFACE STRUCTURE

The ASReference base class provides methods for specifying how elements should be selected: -byIndex:, -byName:, etc.

The ASCommand base class provides a -send method for dispatching events; it also provides methods for specifying event attributes: -resultType:, -ignoreReply/-waitReply/-queueReply, -machPort:, etc.

The glue is responsible for providing application-specific classes and methods for specifying properties, elements, commands and command parameters. All property and element names are folded into a single ...Reference class (note that appscript doesn't generate separate classes representing each dictionary class as this is not analogous to how AppleScript works and leads to compatibility problems with applications). Each command is represented by its own class which provides methods for specifying each keyword parameter individually.


For example, TEGlue.h should look something like the following:


#import "appscript.h"

/**********************************************************************/
/*
 * Information about the TextEdit application which this glue was generated.
 */

NSString *TEApplicationName = @"TextEdit.app";
NSString *TEApplicationPath = @"/Applications/TextEdit.app";
NSString *TEApplicationBundleID = @"com.apple.textedit";
OSType TEApplicationSignature = 'ttxt';
NSString *TEApplicationURL = nil;

/*
 * (Note: This info is mostly just for developer's reference, though some values 
 * may be useful in code as well.
 *
 * (Note: when creating a new TEApplication instance via -init,
 * TEApplicationBundleID(?) will be used to identify application.
 *
 * (Note: may also include application version number where available.)
 */

/**********************************************************************/
/*
 * TextEdit-specific Reference class
 *
 * (Note: clients shouldn't instantiate this class directly; instead, use TEApp,
 * TECon, TEIts or a TEApplication instance to construct new references.)
 */

@interface TEReference : ASReference

// Properties
- (TEReference *)name;
- (TEReference *)text;
...

// Elements
- (TEReference *)documents;
- (TEReference *)windows;
...

// Commands
- (TECommand *)move;
- (TECommand *)move:(id)directParameter;
- (TECommand *)make;
...

/*
 * (Note that each command constructor is defined as a pair of methods,
 * -NAME and -NAME:, optionally allowing a direct parameter to be passed)
 */

@end


/**********************************************************************/
/*
 * TextEdit-specific Command classes
 *
 * (Note: clients shouldn't instantiate these directly)
 */

@interface TEMoveCommand : ASCommand

// Keyword parameters
- (TECommand *)to(id)parameter;


@end


@interface TEMakeCommand : ASCommand

// Keyword parameters
- (TECommand *)new:(id)parameter;
- (TECommand *)at:(id)parameter;
- (TECommand *)withData:(id)parameter;
- (TECommand *)withProperties:(id)parameter;

@end

...

/*
 * (Note that each keyword parameter method returns self, 
 * allowing calls to be chained for convenience)
 */


/**********************************************************************/
// 'Generic' reference roots.
/* 
 * These are instances of TEReference which can be used to construct 
 * app-, con- and its-based references via chained method calls.
 * (Note that they don't carry target info so can't construct commands
 * and send themselves; only the TEApplication object and 
 * TEReferences derived from it can do that.)

TEReference *TEApp;

TEReference *TECon;

TEReference *TEIts;


/**********************************************************************/
/*
 * TEConstant instances provide convenience wrappers around
 * typeType, typeEnumerated, typeProperty descriptors.
 */

@interface TEConstant : ASConstant

// built-in type names
+ (TEConstant)integer;
+ (TEConstant)unicode_text;
+ (TEConstant)alias;
...

// enumerators
+ (TEConstant)yes;
+ (TEConstant)no;
+ (TEConstant)ask;
...

// class names
+ (TEConstant)document;
+ (TEConstant)window;
...

// property names
+ (TEConstant)name;
+ (TEConstant)text;
...

@end


/*
 * (Note: when a TEConstant instance is first created, it may be
 * cached internally and subsequently reused for efficiency.)
 */

/**********************************************************************/
/*
 * TEApplication instances are used to construct 'real' references
 * and construct and send commands to the target application.
 *
 * Clients can specify exactly how applications should be identified
 * (e.g. by PID, URL, etc.) and create multiple instances if needed.
 */

@interface TEApplication : TEReference
@end

/*
 * Note: TEApplication needs various additional methods added via mixin:
 *
 *    -initWithName:
 *    -initWithPath:
 *    -initWithPID:
 *    -initWithBundleID:
 *    -initWithURL:
 *    -initWithAEAddressDesc:
 *    -startTransaction
 *    -endTransaction
 *    -abortTransaction
 *    -launch
 *    ...
 */


/**********************************************************************/

======================================================================
GLUE IMPLEMENTATION STRUCTURE

The implementation for each glue method is minimal. For example, each TEReference property/element method constructs a new AEM reference using the appropriate OSType, wraps it in a new (autoreleased) TEReference instance, and returns the result.


@implementation TEReference

// (Note: appData and aemReference ivars are defined in ASReference)

// Properties
- (TEReference *)name {
    return [TEReference referenceWithAppData: appData
            aemReference: [aemReference property: 'pnam']];
}
...

// Elements
- (TEReference *)documents {
    return [TEReference referenceWithAppData: appData
            aemReference: [aemReference elements: 'docu']];
}
...

// Commands
- (TECommand *)move {
    return [TECommand commandWithAppData: appData
            eventClass: 'core'
            eventID: 'move'
            directParameter: nil
            parentReference: self];
}

- (TECommand *)move:(id)directParameter {
    return [TECommand commandWithAppData: appData
            eventClass: 'core'
            eventID: 'move'
            directParameter: directParameter
            parentReference: self];
}
...

@end


======================================================================
EXAMPLES

- Identifying applications:

    // set textedit to application "TextEdit"

    TEApplication *textedit;

    textedit = [[TEApplication alloc] init]; // auto-locates app by bundle ID
    textedit = [[TEApplication alloc] initWithPath: @"/Applications/TextEdit.app"];
    textedit = [[TEApplication alloc] initWithURL: @"eppc://my-mac.local/TextEdit"];


- Building application references:

    // tell app "TextEdit" to set ref to a reference to text of document 1

    TEReference *textRef = [[[textedit documents] byIndex: [NSNumber numberWithLong: 1]] text];

Note: for convenience, the above can also be written as:

    TEReference *textRef = [[[textedit documents] at: 1] text];


- Building and sending commands:

    // tell app "TextEdit" to set text of document 1 to "hello world"

    [[[textedit set: textRef] to: @"Hello"] send];


    // tell app "TextEdit" to get text of document 1

    id reply = [[textEdit get: textRef] send];
    NSLog(@"TextEdit says %@\n", reply); // "TextEdit says Hello!"


// tell app "TextEdit" to make new document with properties {text:"Hi!"}

    TECommand *makeCmd = [textedit make];
    [makeCmd new: TEConstant document];
    [makeCmd withProperties: [NSDictionary dictionaryWithObjectsAndKeys: @"Hi!", [TEConstant text]]];
    TEReference *newDocRef = [makeCmd send];


    TEReference *newDocRef = [[[[textedit make]
            new: TEConstant document]
            withProperties: [NSDictionary dictionaryWithObjectsAndKeys: @"Hi!", [TEConstant text]]]
            send];


- Shortcuts: 

For convenience, commands can also be called on references, in which case the reference is used as the direct parameter (unless the command already has a direct parameter specified, in which case the reference is packed as the event's subject attribute):

    [[textRef set] to: @"Hello!"] send];
    id reply = [[textRef get] send];


ASReference also provides convenience shortcuts for the commonly-used 'get' and 'set' commands:

    [textRef rset: @"Hello!"];
    [textRef rget];


